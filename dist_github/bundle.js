(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["sframe"] = factory();
	else
		root["sframe"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/Client.js":
/*!***********************!*\
  !*** ./lib/Client.js ***!
  \***********************/
/*! exports provided: SFrame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SFrame\", function() { return SFrame; });\n//Get worker url\n// import Worker from 'worker-loader!./Worker.js';\nconst Worker = __webpack_require__(/*! ./sframe.worker */ \"./lib/sframe.worker.js\").default;\nconsole.log('Worker: ', Worker);\n\n/**\n * SFrame library\n *  @namespace Sframe\n */\nconst SFrame =\n{\n\t/**\n\t * Create a new SFrame client context.\n\t *\n\t * This method will create client which communicates with web worker in which the SFrame context will be executed.\n\t * @memberof SFrame\n\t * @param {Number} senderId - Numeric id for this sender.\n\t * @param {Object} config - Congiguration parameters [Optional].\n\t * @param {Boolean} config.skipVp8PayloadHeader - Sends the vp8 payload header in clear (Note: it will be applied to all video frames as encoded chunks does not contain codec info yet).\n\t * @returns {Promise<Client>} Promise that resolves to the client object when the web worker is initialized.\n\t */\n\tcreateClient : async function(senderId,config)\n\t{\n\t\t//Create client\n\t\tconst client = new Client();\n\t\t//Init worker async\n\t\tawait client.init(senderId, config);\n\t\t//Return client\n\t\treturn client;\n\t}\n};\n\nasync function transferKey(key)\n{\n\tif (key instanceof CryptoKey && key.type==\"private\")\n\t\treturn await crypto.subtle.exportKey(\"pkcs8\", key);\n\tif (key instanceof CryptoKey)\n\t\treturn await crypto.subtle.exportKey(\"raw\", key);\n\tif (key instanceof Uint8Array)\n\t\treturn key.buffer.slice(0);\n\treturn key.slice(0);\n}\n\n\n/**\n * The SFrame client object which acts as a proxy for web worker context.\n */\nclass Client extends EventTarget\n{\n\t/**\n\t * @ignore\n\t * @hideconstructor\n\t * private constructor\n\t */\n\tconstructor()\n\t{\n\t\t super();\n\n\t\t//Create new worker\n\t\tthis.worker = new Worker();\n\n\t\t//Cutrent transactions\n\t\tthis.transId = 1;\n\t\tthis.transactions = new Map();\n\n\t\t//Listen for worker messages\n\t\tthis.worker.addEventListener(\"message\",async (event)=>{\n\t\t\t//Get data\n\t\t\tconst data = event.data;\n\t\t\t//If it is a transaction response\n\t\t\tif (data.transId)\n\t\t\t{\n\t\t\t\t//Get transaction\n\t\t\t\tconst transaction = this.transactions.get(data.transId);\n\t\t\t\t//Delete transaction\n\t\t\t\tthis.transactions.delete(data.transId);\n\t\t\t\t//Check result\n\t\t\t\tif (data.error)\n\t\t\t\t    //Reject with error\n\t\t\t\t\ttransaction.reject(new Error(data.error));\n\t\t\t\telse\n\t\t\t\t\t//Resolve promise\n\t\t\t\t\ttransaction.resolve(data.result);\n\t\t\t} else if (data.event) {\n\t\t\t\t/**\n\t\t\t\t* The authenticated event will be fired when a new sender is received on the receiver.\n\t\t\t\t*\n\t\t\t\t* @name \"authenticated\"\n\t\t\t\t* @memberof Client\n\t\t\t\t* @kind event\n\t\t\t\t* @argument {String} id - The id for the associated RTCRtpReceiver\n\t\t\t\t* @argument {Number} senderId - The senderId of the authenticated sender received.\n\t\t\t\t*/\n\t\t\t\t//Create event\n\t\t\t\tconst event = new Event(data.event.name);\n\t\t\t\t//Set id and senderId\n\t\t\t\tevent.id\t= data.event.data.id;\n\t\t\t\tevent.senderId\t= data.event.data.senderId;\n\t\t\t\t//Disptach event\n\t\t\t\tthis.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t\t//Private method\n\t\tthis.postMessage = (cmd, args, transferList)=>{\n\t\t\t//Create new promise\n\t\t\treturn new Promise((resolve,reject)=>{\n\t\t\t\t//Get new transaction\n\t\t\t\tconst transId = this.transId++;\n\t\t\t\t//Sent to worker\n\t\t\t\tthis.worker.postMessage({transId,cmd,args},transferList);\n\t\t\t\t//Add it to pending transactions\n\t\t\t\tthis.transactions.set(transId,{resolve,reject});\n\t\t\t});\n\t\t};\n\t}\n\n\tasync init(senderId, config)\n\t{\n\t\treturn this.postMessage(\"init\", {senderId, config});\n\t}\n\n\t/**\n\t * Set the sender encryption key.\n\t *\n\t * @param {ArrayBuffer|Uint8Array|CryptoKey} key - 32 bytes encryption key. If the value is a CryptoKey the algorithm must be \"HKDF\".\n\t * @returns {Promise<void>} Promise which will be resolved when the key is set on the web worker.\n\t */\n\tasync setSenderEncryptionKey(key)\n\t{\n\t\tconst transfered = await transferKey(key);\n\t\treturn this.postMessage(\"setSenderEncryptionKey\", [transfered], [transfered]);\n\t}\n\n\t/**\n\t * Ratchert the sender encryption key.\n\t *\n\t * @returns {Promise<void>} Promise which will be resolved when the key is ratcheted on the web worker.\n\t */\n\tasync ratchetSenderEncryptionKey()\n\t{\n\t\treturn this.postMessage(\"ratchetSenderEncryptionKey\");\n\t}\n\n\t/**\n\t * Set the sender signing key.\n\t *\n\t * @param {ArrayBuffer|Uint8Array|CryptoKey} key - Private key used for singing. If the value is a CryptoKey the algorithm must be \"ECDSA\".\n\t * @returns {Promise<void>} Promise which will be resolved when the signing key is set on the web worker.\n\t */\n\tasync setSenderSigningKey(key)\n\t{\n\t\tconst transfered = await transferKey(key);\n\t\treturn this.postMessage(\"setSenderSigningKey\", [transfered]);\n\t}\n\n\t/**\n\t * Add receiver for a remote sender.\n\t *\n\t * @param {Number} receiverkKeyId - The remote senderId.\n\t * @returns {Promise<void>} Promise which will be resolved when the receiver is added on the web worker.\n\t */\n\tasync addReceiver(receiverkKeyId)\n\t{\n\t\treturn this.postMessage(\"addReceiver\", [receiverkKeyId]);\n\t}\n\n\t/**\n\t * Set the receiver encryption key associated to a remote sender.\n\t *\n\t * @param {Number} receiverkKeyId - The remote senderId.\n\t * @param {ArrayBuffer|Uint8Array|CryptoKey} key - 32 bytes encryption key. If the value is a CryptoKey the algorithm must be \"HKDF\".\n\t * @returns {Promise<void>} Promise which will be resolved when the key is set on the web worker.\n\t */\n\tasync setReceiverEncryptionKey(receiverkKeyId,key)\n\t{\n\t\tconst transfered = await transferKey(key);\n\t\treturn this.postMessage(\"setReceiverEncryptionKey\", [receiverkKeyId, transfered], [transfered]);\n\t}\n\n\t/**\n\t * Set the receiver signing key associated to a remote sender.\n\t *\n\t * @param {Number} receiverkKeyId - The remote senderId.\n\t * @param {ArrayBuffer|Uint8Array|CryptoKey} key - Private key used for singing. If the value is a CryptoKey the algorithm must be \"ECDSA\".\n\t * @returns {Promise<void>} Promise which will be resolved when the signing key is set on the web worker.\n\t */\n\tasync setReceiverVerifyKey(receiverkKeyId,key)\n\t{\n\t\tconst transfered = await transferKey(key);\n\t\treturn this.postMessage(\"setReceiverVerifyKey\", [receiverkKeyId, transfered], [transfered]);\n\t}\n\n\t/**\n\t * Remove receiver for a remote sender.\n\t *\n\t * @param {Number} receiverkKeyId - The remote senderId.\n\t * @returns {Promise<void>} Promise which will be resolved when the receiver is removed on the web worker.\n\t */\n\tdeleteReceiver(receiverkKeyId)\n\t{\n\t\treturn this.postMessage(\"deleteReceiver\", [receiverkKeyId]);\n\t}\n\n\t/**\n\t * Encrypt frames for a RTCRtpSender.\n\t *\n\t * @param {String} id - An unique identifier associated to this sender (for example transceiver.mid).\n\t * @param {RTCRtpSender} sender - The sender object, associated track must be not null.\n\t */\n\tasync encrypt(id,sender)\n\t{\n\t\t //We need the media kind until it is set as metadata on the chunk frame\n\t\tconst kind = sender.track.kind;\n\t\t//Get the sender insertable streams\n\t\tconst {readable: readableStream, writable: writableStream} = sender.createEncodedStreams ? sender.createEncodedStreams() :\n\t\t\tsender.createEncodedVideoStreams ? sender.createEncodedVideoStreams() : sender.createEncodedAudioStreams();\n\t\t//Pass to worker\n\t\treturn this.postMessage(\"encrypt\",\n\t\t\t{id, kind, readableStream, writableStream},\n\t\t\t[readableStream, writableStream]\n\t\t);\n\t}\n\n\t/**\n\t * Decrypt frames fpr a RTCPRtpReceiver.\n\t *\n\t * @param {String} id - An unique identifier associated to this sender (for example transceiver.mid), it will be used for the authentication and signing events.\n\t * @param {RTCRtpReceiver} receiver - The receiver object.\n\t */\n\tasync decrypt(id,receiver)\n\t{\n\t\t//We need the media kind until it is set as metadata on the chunk frame\n\t\tconst kind = receiver.track.kind;\n\t\t//Get the receiver insertable streams\n\t\tconst {readable: readableStream, writable: writableStream} = receiver.createEncodedStreams ? receiver.createEncodedStreams() :\n\t\t\treceiver.createEncodedVideoStreams ? receiver.createEncodedVideoStreams() : receiver.createEncodedAudioStreams();\n\t\t//Pass to worker\n\t\treturn this.postMessage(\"decrypt\",\n\t\t\t{id, kind, readableStream, writableStream},\n\t\t\t[readableStream, writableStream]\n\t\t);\n\t}\n\n\t/**\n\t * Close client and terminate web worker.\n\t */\n\tclose()\n\t{\n\t\t//Terminate worker\n\t\tthis.worker.terminate();\n\n\t\t//End all pending transactions\n\t\tfor (let transaction of this.transactions.values())\n\t\t\t//Reject with terminated error\n\t\t\ttransaction.reject(new Error(\"Client closed\"));\n\t\t//Clear transactions\n\t\tthis.transactions.clear();\n\t}\n};\n\n\n//# sourceURL=webpack://sframe/./lib/Client.js?");

/***/ }),

/***/ "./lib/Utils.js":
/*!**********************!*\
  !*** ./lib/Utils.js ***!
  \**********************/
/*! exports provided: Utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utils\", function() { return Utils; });\nconst Utils = \n{\n\ttoHex : function(buffer)\n\t{\n\t\treturn Array.prototype.map.call(buffer instanceof Uint8Array ? buffer : new Uint8Array (buffer), x =>x.toString(16).padStart(2,\"0\")).join(\"\");\n\t},\n\tfromHex: function(str)\n\t{\n\t\tconst bytes = [];\n\t\tfor (let i=0;i<str.length/2;++i)\n\t\t\tbytes.push(parseInt(str.substring(i*2, (i+1)*2), 16));\n\n\t\treturn new Uint8Array(bytes);\n\t},\n\tequals : function(a,b)\n\t{\n\t\tif (a.byteLength != b.byteLength) return false;\n\t\tfor (let i = 0 ; i != a.byteLength ; i++)\n\t\t\tif (a[i] != b[i]) return false;\n\t\treturn true;\n\t}\n};\n\n\n//# sourceURL=webpack://sframe/./lib/Utils.js?");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/*! exports provided: Utils, SFrame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Utils\", function() { return _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"]; });\n\n/* harmony import */ var _Client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Client */ \"./lib/Client.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SFrame\", function() { return _Client__WEBPACK_IMPORTED_MODULE_1__[\"SFrame\"]; });\n\n\n\n\n\n\n\n//# sourceURL=webpack://sframe/./lib/index.js?");

/***/ }),

/***/ "./lib/sframe.worker.js":
/*!******************************!*\
  !*** ./lib/sframe.worker.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Worker_fn; });\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/worker-loader/dist/runtime/inline.js */ \"./node_modules/worker-loader/dist/runtime/inline.js\");\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nfunction Worker_fn() {\n  return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./lib/sframe.worker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./lib/sframe.worker.js\\\":\\n/*!******************************!*\\\\\\n  !*** ./lib/sframe.worker.js ***!\\n  \\\\******************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\neval(\\\"/*\\\\n  0 1 2 3 4 5 6 7\\\\n  +-+-+-+-+-+-+-+-+\\\\n  |S|LEN  |X|  K  |\\\\n  +-+-+-+-+-+-+-+-+\\\\n  SFrame header metadata\\\\n\\\\n  Signature flag (S): 1 bit This field indicates the payload contains a signature of set. Counter Length (LEN): 3 bits This field indicates the length of the CTR fields in bytes. Extended Key Id Flag (X): 1 bit\\\\n  Indicates if the key field contains the key id or the key length. Key or Key Length: 3 bits This field contains the key id (KID) if the X flag is set to 0, or the key length (KLEN) if set to 1.\\\\n\\\\n  If X flag is 0 then the KID is in the range of 0-7 and the frame counter (CTR) is found in the next LEN bytes:\\\\n\\\\n  0 1 2 3 4 5 6 7\\\\n  +-+-+-+-+-+-+-+-+---------------------------------+\\\\n  |S|LEN  |0| KID |    CTR... (length=LEN)          |\\\\n  +-+-+-+-+-+-+-+-+---------------------------------+\\\\n  Key id (KID): 3 bits The key id (0-7). Frame counter (CTR): (Variable length) Frame counter value up to 8 bytes long.\\\\n\\\\n  if X flag is 1 then KLEN is the length of the key (KID), that is found after the SFrame header metadata byte. After the key id (KID), the frame counter (CTR) will be found in the next LEN bytes:\\\\n\\\\n  0 1 2 3 4 5 6 7\\\\n  +-+-+-+-+-+-+-+-+---------------------------+---------------------------+\\\\n  |S|LEN  |1|KLEN |   KID... (length=KLEN)    |    CTR... (length=LEN)    |\\\\n  +-+-+-+-+-+-+-+-+---------------------------+---------------------------+\\\\n*/\\\\nconst Header = {\\\\n\\\\n  parse : function(buffer)\\\\n  {\\\\n    //Create uint view\\\\n    const view = new Uint8Array(buffer);\\\\n\\\\n    //Get metadata\\\\n    const metadata = view[0];\\\\n\\\\n    //Get values\\\\n    const s\\\\t\\\\t= !!(metadata & 0x80);\\\\n    const len\\\\t= (metadata >> 4) & 0x07;\\\\n    const x\\\\t\\\\t= !!(metadata & 0x08);\\\\n    const k\\\\t\\\\t= metadata & 0x07;\\\\n\\\\n    //Get key id\\\\n    let keyId = 0;\\\\n    //Check if it is the extented key format\\\\n    if (x)\\\\n    {\\\\n      //Read length\\\\n      for (let i=0;i<k;i++)\\\\n        keyId = (keyId * 256) + view[i+1];\\\\n    } else {\\\\n      //Short version\\\\n      keyId = k;\\\\n    }\\\\n\\\\n    //Get ctr\\\\n    const ini = x ? k + 1 : 1;\\\\n    let counter = 0;\\\\n    //Read length\\\\n    for (let i=0;i<len;i++)\\\\n      counter = (counter * 256) + view[ini+i];\\\\n\\\\n    //Get header buffer view\\\\n    const header = view.subarray(0, x ? k + len + 1 : len + 1);\\\\n\\\\n    //Add parsed atributes\\\\n    header.signature   = s;\\\\n    header.keyId\\\\t   = keyId;\\\\n    header.counter\\\\t   = counter;\\\\n\\\\n    //Done\\\\n    return header;\\\\n  },\\\\n  generate: function(signature,keyId,counter)\\\\n  {\\\\n    //Check keyId\\\\n    Header.checkKeyId(keyId);\\\\n\\\\n    //Calcultate variavle length\\\\n    const varlen = (x) => x ? parseInt(Math.log(x) / Math.log(256))+1 : 1;\\\\n\\\\n    //Get key extension and length\\\\n    const x = keyId > 7;\\\\n    const k = x ? varlen(keyId) : keyId;\\\\n\\\\n    //Get counter length\\\\n    const len = varlen(counter);\\\\n\\\\n    //Ensure counter is not huge\\\\n    if (len>7)\\\\n      //Error\\\\n      throw new Error(\\\\\\\"Counter is too big\\\\\\\");\\\\n\\\\n    //Generate header\\\\n    const header = new Uint8Array( x ? 1 + k + len : 1 + len);\\\\n\\\\n    //Set metadata header\\\\n    header[0] = !!signature;\\\\n    header[0] = header[0] << 3  | ( len & 0x07);\\\\n    header[0] = header[0] << 1  | x;\\\\n    header[0] = header[0] << 3  | ( k & 0x07);\\\\n\\\\n    //Add parsed atributes\\\\n    header.signature   = !!signature;\\\\n    header.keyId\\\\t   = keyId;\\\\n    header.counter\\\\t   = counter;\\\\n\\\\n    //If extended key\\\\n    if (x)\\\\n      //Add key id\\\\n      for (let i=0; i<k; ++i)\\\\n        header[i+1] = (keyId >> (k-1-i)*8) & 0xff;\\\\n    //The coutner init\\\\n    const ini = x ? k + 1 : 1;\\\\n    //Add counter\\\\n    for (let i=0; i<len; ++i)\\\\n      header[ini+i] = (counter >> (len-1-i)*8) & 0xff;\\\\n\\\\n\\\\n    //Done\\\\n    return header;\\\\n  }\\\\n};\\\\n\\\\nHeader.MaxKeyId = 0xFFFFFFFFFF;\\\\n\\\\nHeader.checkKeyId = function(keyId)\\\\n{\\\\n  //Check it is possitive\\\\n  if (keyId<0)\\\\n    //Error\\\\n    throw new Error(\\\\\\\"keyId must be possitive\\\\\\\");\\\\n  //Check it is possitive\\\\n  if (keyId>Header.MaxKeyId)\\\\n    //Error\\\\n    throw new Error(\\\\\\\"keyId must be 5 bytes long at most\\\\\\\");\\\\n};\\\\n\\\\n//TODO: Update to Ed25519 when available\\\\n// https://chromestatus.com/features/4913922408710144\\\\n// https://chromium.googlesource.com/chromium/src/+log/master/components/webcrypto/algorithms/ed25519.cc\\\\n\\\\nclass EcdsaSignKey\\\\n{\\\\n\\\\n  async setKey(privKey)\\\\n  {\\\\n    //If it is a crypto key already\\\\n    if (privKey instanceof CryptoKey)\\\\n    {\\\\n      //Check private key algorithm\\\\n      if (privKey.algorithm.name!=\\\\\\\"ECDSA\\\\\\\" || !privKey.usages.includes(\\\\\\\"sign\\\\\\\"))\\\\n        //Error\\\\n        throw new Error(\\\\\\\"Invalid key\\\\\\\");\\\\n      //Set it\\\\n      this.privKey = privKey;\\\\n    } else {\\\\n      //Import it\\\\n      this.privKey = await crypto.subtle.importKey(\\\\n        \\\\\\\"pkcs8\\\\\\\",\\\\n        privKey,\\\\n        {\\\\n          name\\\\t\\\\t: \\\\\\\"ECDSA\\\\\\\",\\\\n          namedCurve\\\\t: \\\\\\\"P-521\\\\\\\"\\\\n        },\\\\n        false,\\\\n        [\\\\\\\"sign\\\\\\\"]\\\\n      );\\\\n    }\\\\n  }\\\\n\\\\n  async sign(authTags)\\\\n  {\\\\n    //Verify\\\\n    return new Uint8Array(await crypto.subtle.sign(\\\\n      {\\\\n        name: \\\\\\\"ECDSA\\\\\\\",\\\\n        hash: \\\\\\\"SHA-512\\\\\\\"\\\\n      },\\\\n      this.privKey,\\\\n      authTags\\\\n    ));\\\\n  }\\\\n\\\\n  static getSignatureLen()\\\\n  {\\\\n    return 64;\\\\n  }\\\\n\\\\n  static async create(privKey)\\\\n  {\\\\n    //Craete key\\\\n    const key = new EcdsaSignKey();\\\\n    //Set key\\\\n    await key.setKey(privKey);\\\\n    //Done\\\\n    return key;\\\\n\\\\n  }\\\\n};\\\\n\\\\nconst Utils =\\\\n  {\\\\n    toHex : function(buffer)\\\\n    {\\\\n      return Array.prototype.map.call(buffer instanceof Uint8Array ? buffer : new Uint8Array (buffer), x =>x.toString(16).padStart(2,\\\\\\\"0\\\\\\\")).join(\\\\\\\"\\\\\\\");\\\\n    },\\\\n    fromHex: function(str)\\\\n    {\\\\n      const bytes = [];\\\\n      for (let i=0;i<str.length/2;++i)\\\\n        bytes.push(parseInt(str.substring(i*2, (i+1)*2), 16));\\\\n\\\\n      return new Uint8Array(bytes);\\\\n    },\\\\n    equals : function(a,b)\\\\n    {\\\\n      if (a.byteLength != b.byteLength) return false;\\\\n      for (let i = 0 ; i != a.byteLength ; i++)\\\\n        if (a[i] != b[i]) return false;\\\\n      return true;\\\\n    }\\\\n  };\\\\n\\\\nconst textEncoder = new TextEncoder()\\\\n\\\\nconst Salts =  {\\\\n  \\\\\\\"SaltKey\\\\\\\"\\\\t\\\\t: textEncoder.encode(\\\\\\\"SFrameSaltKey\\\\\\\"),\\\\n  \\\\\\\"EncryptionKey\\\\\\\"\\\\t\\\\t: textEncoder.encode(\\\\\\\"SFrameEncryptionKey\\\\\\\"),\\\\n  \\\\\\\"AuthenticationKey\\\\\\\"\\\\t: textEncoder.encode(\\\\\\\"SFrameAuthenticationKey\\\\\\\"),\\\\n  \\\\\\\"RatchetKey\\\\\\\"\\\\t\\\\t: textEncoder.encode(\\\\\\\"SFrameRatchetKey\\\\\\\")\\\\n};\\\\n\\\\nconst IV =\\\\n  {\\\\n    generate : function(keyId,counter,salt)\\\\n    {\\\\n      //128 bits\\\\n      const iv = new Uint8Array (16);\\\\n      //Get view\\\\n      const view = new DataView(iv.buffer);\\\\n      //Set keyId\\\\n      view.setBigUint64(0, BigInt(counter));\\\\n      //Set coutner\\\\n      view.setBigUint64(8, BigInt(keyId));\\\\n      //Xor with salt key\\\\n      for (let i=0; i<iv.byteLength; ++i)\\\\n        //xor\\\\n        view.setUint8(i,iv[i]^salt[i]);\\\\n      //return buffer\\\\n      return iv;\\\\n    }\\\\n  };\\\\n\\\\nclass AesCm128HmacSha256EncryptionKey\\\\n{\\\\n  async setKey(key)\\\\n  {\\\\n    if (key instanceof CryptoKey)\\\\n    {\\\\n      //Check private key algorithm\\\\n      if (key.algorithm.name!=\\\\\\\"HKDF\\\\\\\")\\\\n        //Error\\\\n        throw new Error(\\\\\\\"Invalid key\\\\\\\");\\\\n    } else {\\\\n      //Import key\\\\n      key = await crypto.subtle.importKey(\\\\n        \\\\\\\"raw\\\\\\\",\\\\n        key,\\\\n        \\\\\\\"HKDF\\\\\\\",\\\\n        false,\\\\n        [\\\\\\\"deriveBits\\\\\\\", \\\\\\\"deriveKey\\\\\\\"]\\\\n      );\\\\n    }\\\\n\\\\n    //Get salt key\\\\n    this.saltKey = new Uint8Array(await crypto.subtle.deriveBits(\\\\n      {\\\\n        name : \\\\\\\"HKDF\\\\\\\",\\\\n        hash : \\\\\\\"SHA-256\\\\\\\",\\\\n        salt : Salts.SaltKey,\\\\n        info : new ArrayBuffer()\\\\n      },\\\\n      key,\\\\n      128\\\\n    ));\\\\n\\\\n    //Get encryption key\\\\n    this.encryptionKey = await crypto.subtle.deriveKey(\\\\n      {\\\\n        name : \\\\\\\"HKDF\\\\\\\",\\\\n        hash : \\\\\\\"SHA-256\\\\\\\",\\\\n        salt : Salts.EncryptionKey,\\\\n        info : new ArrayBuffer()\\\\n      },\\\\n      key,\\\\n      {\\\\n        name : \\\\\\\"AES-CTR\\\\\\\",\\\\n        length : 128\\\\n      },\\\\n      false,\\\\n      [\\\\\\\"encrypt\\\\\\\",\\\\\\\"decrypt\\\\\\\"]\\\\n    );\\\\n\\\\n    //Get authentication key\\\\n    this.authKey = await crypto.subtle.deriveKey(\\\\n      {\\\\n        name : \\\\\\\"HKDF\\\\\\\",\\\\n        hash : \\\\\\\"SHA-256\\\\\\\",\\\\n        salt : Salts.AuthenticationKey,\\\\n        info : new ArrayBuffer()\\\\n      },\\\\n      key,\\\\n      {\\\\n        name : \\\\\\\"HMAC\\\\\\\",\\\\n        hash : \\\\\\\"SHA-256\\\\\\\",\\\\n        length : 256\\\\n      },\\\\n      false,\\\\n      [\\\\\\\"sign\\\\\\\",\\\\\\\"verify\\\\\\\"]\\\\n    );\\\\n\\\\n    //Derive Ratchet key\\\\n    this.ratchetKey = await crypto.subtle.deriveBits(\\\\n      {\\\\n        name : \\\\\\\"HKDF\\\\\\\",\\\\n        hash : \\\\\\\"SHA-256\\\\\\\",\\\\n        salt : Salts.RatchetKey,\\\\n        info : new ArrayBuffer()\\\\n      },\\\\n      key,\\\\n      256\\\\n    );\\\\n  }\\\\n\\\\n  async encrypt(type,header,payload,extraBytes,skip)\\\\n  {\\\\n    //Encure int\\\\n    skip = skip ? skip : 0;\\\\n\\\\n    //Create IV\\\\n    const iv = IV.generate(header.keyId, header.counter, this.saltKey);\\\\n\\\\n    //Encrypt\\\\n    const encrypted = await crypto.subtle.encrypt(\\\\n      {\\\\n        name\\\\t: \\\\\\\"AES-CTR\\\\\\\",\\\\n        counter : iv,\\\\n        length  : 128\\\\n      },\\\\n      this.encryptionKey,\\\\n      payload\\\\n    );\\\\n\\\\n    //Get auth tag length from media type\\\\n    const authTagLength = AesCm128HmacSha256EncryptionKey.getAuthTagLen(type);\\\\n\\\\n    //Create encrypted frame\\\\n    const encryptedFrame = new Uint8Array(header.byteLength + payload.byteLength + authTagLength + extraBytes + skip);\\\\n\\\\n    //Set header and encrypted payolad\\\\n    encryptedFrame.set(header, skip);\\\\n    encryptedFrame.set(new Uint8Array(encrypted), skip + header.length);\\\\n\\\\n    //Authenticate\\\\n    const signature = new Uint8Array(await crypto.subtle.sign(\\\\n      \\\\\\\"HMAC\\\\\\\",\\\\n      this.authKey,\\\\n      encryptedFrame.subarray(skip, skip + header.byteLength + encrypted.byteLength)\\\\n    ));\\\\n\\\\n    //Truncate\\\\n    const authTag = signature.subarray(0, authTagLength);\\\\n\\\\n    //Append authentication tag\\\\n    encryptedFrame.set(authTag, skip + encrypted.byteLength + header.byteLength );\\\\n\\\\n    //Done\\\\n    return [encryptedFrame,authTag];\\\\n\\\\n  }\\\\n\\\\n  async decrypt(type, header, encryptedFrame, extrabytes, skip)\\\\n  {\\\\n    //Encure int\\\\n    skip = skip ? skip : 0;\\\\n\\\\n    //Create IV\\\\n    const iv = IV.generate(header.keyId, header.counter, this.saltKey);\\\\n\\\\n    //Get auth tag length from media type\\\\n    const authTagLength = AesCm128HmacSha256EncryptionKey.getAuthTagLen(type);\\\\n\\\\n    //Get encrypted frame length (without extra bytes from signature)\\\\n    const frameLength = encryptedFrame.byteLength - extrabytes - skip;\\\\n\\\\n    //Get authentication tag\\\\n    const authTag = encryptedFrame.subarray(skip + frameLength - authTagLength, skip + frameLength);\\\\n\\\\n    //Get encrypted payload\\\\n    const encrypted = encryptedFrame.subarray(skip + header.byteLength, skip + frameLength - authTagLength);\\\\n\\\\n    //Calculate signature\\\\n    const signature = new Uint8Array(await crypto.subtle.sign(\\\\n      \\\\\\\"HMAC\\\\\\\",\\\\n      this.authKey,\\\\n      encryptedFrame.subarray(skip, skip + header.byteLength + encrypted.byteLength)\\\\n    ));\\\\n\\\\n    //Authenticate authTag\\\\n    let authenticated = true;\\\\n    //Avoid timimg attacks by iterating over all bytes\\\\n    for (let i=0;i<authTagLength;++i)\\\\n      //check signature\\\\n      authenticated &= authTag[i]===signature[i];\\\\n\\\\n    //If not all where equal\\\\n    if (!authenticated)\\\\n      //Authentication error\\\\n      throw new Error(\\\\\\\"Authentication error\\\\\\\");\\\\n\\\\n    //Decrypt\\\\n    const payload = new Uint8Array (await crypto.subtle.decrypt(\\\\n      {\\\\n        name\\\\t: \\\\\\\"AES-CTR\\\\\\\",\\\\n        counter : iv,\\\\n        length  : 128\\\\n      },\\\\n      this.encryptionKey,\\\\n      encrypted\\\\n    ));\\\\n\\\\n    //Done\\\\n    return [payload, authTag];\\\\n  }\\\\n\\\\n  async ratchet()\\\\n  {\\\\n    //Create new key\\\\n    const key = new AesCm128HmacSha256EncryptionKey();\\\\n\\\\n    //Set ratchet key\\\\n    await key.setKey(this.ratchetKey);\\\\n\\\\n    //Done\\\\n    return key;\\\\n  }\\\\n\\\\n  static getAuthTagLen(type)\\\\n  {\\\\n    return type.toLowerCase()===\\\\\\\"video\\\\\\\" ? 10 : 4;\\\\n  };\\\\n\\\\n  static async create(raw)\\\\n  {\\\\n    //Create new key\\\\n    const key = new AesCm128HmacSha256EncryptionKey();\\\\n    //Set raw key\\\\n    await key.setKey(raw);\\\\n    //Done\\\\n    return key;\\\\n  }\\\\n};\\\\n\\\\n\\\\nconst SigningFrameInterval = 10;\\\\n\\\\nclass Sender\\\\n{\\\\n  constructor(senderId)\\\\n  {\\\\n    //Check keyId\\\\n    Header.checkKeyId(senderId);\\\\n\\\\n    //The global frame counter\\\\n    this.counter = 0;\\\\n\\\\n    //Store senderId/keyId\\\\n    this.senderId = senderId;\\\\n\\\\n    //Pending frames for signing\\\\n    this.pending = new Map();\\\\n  }\\\\n\\\\n  async encrypt(type, ssrcId, payload, skip)\\\\n  {\\\\n    // console.warn('BOO: BigWorker.Sender: encrypt');\\\\n    //Check we have a valid key\\\\n    if (!this.key)\\\\n      throw Error(\\\\\\\"Encryption key not set\\\\\\\");\\\\n\\\\n    //convert if needed\\\\n    if (!(payload instanceof Uint8Array))\\\\n      payload = new Uint8Array (payload);\\\\n\\\\n    //Encure int\\\\n    skip = skip ? skip : 0;\\\\n\\\\n    //Get counter for frame\\\\n    const counter = this.counter++;\\\\n\\\\n    //If we don't have the ssrc\\\\n    if (!this.pending.has(ssrcId))\\\\n      //Create new pending frames array\\\\n      this.pending.set(ssrcId,[]);\\\\n\\\\n    //Get pending frames for signature\\\\n    const pending = this.pending.get(ssrcId);\\\\n\\\\n    //Do we need to sign the frames?\\\\n    const signing = this.signingKey && pending.length > SigningFrameInterval;\\\\n\\\\n    //Get auth tag len for type\\\\n    const authTagLen = AesCm128HmacSha256EncryptionKey.getAuthTagLen(type);\\\\n\\\\n    //Calculae extra bytes\\\\n    const extraBytes = signing ? pending.length * AesCm128HmacSha256EncryptionKey.getAuthTagLen(type) + 1 + EcdsaSignKey.getSignatureLen() : 0;\\\\n\\\\n    //Generate header\\\\n    const header = Header.generate(signing,this.senderId,counter);\\\\n\\\\n    //Encrypt frame\\\\n    const [encryptedFrame,authTag] = await this.key.encrypt(type, header, payload, extraBytes, skip);\\\\n\\\\n    //If we are sending part of the frame in clear\\\\n    if (skip)\\\\n      //Copy skiped payload\\\\n      encryptedFrame.set(payload.subarray(0,skip),0);\\\\n\\\\n    //If we need to sign the frame\\\\n    if (signing)\\\\n    {\\\\n      //Append after auth tag\\\\n      let ini = skip + encryptedFrame.byteLength - extraBytes;\\\\n\\\\n      //Get tag list view\\\\n      const authTags = encryptedFrame.subarray(ini - authTagLen, (pending.length + 1) * authTagLen);\\\\n\\\\n      //Add all previous tags\\\\n      for (const previousTag of pending)\\\\n      {\\\\n        //Append to frame\\\\n        encryptedFrame.set(previousTag, ini);\\\\n        //Move\\\\n        ini += authTagLen;\\\\n      }\\\\n\\\\n      //Add number of bytes\\\\n      encryptedFrame[ini++] = pending.length;\\\\n\\\\n      //Create signature with all auth tags (including this frame's one)\\\\n      const signature = await this.signingKey.sign(authTags);\\\\n\\\\n      //Add signature\\\\n      encryptedFrame.set(signature, ini);\\\\n\\\\n      //Empty pending list\\\\n      this.pending.set(ssrcId,[]);\\\\n\\\\n      //If we can sign\\\\n    } else if (this.signingKey) {\\\\n      //Append a copy of current tag at the begining\\\\n      pending.unshift(authTag.slice());\\\\n    }\\\\n\\\\n    //Set authenticated sender id and frame Id\\\\n    encryptedFrame.senderId = header.keyId;\\\\n    encryptedFrame.frameId  = header.counter;\\\\n\\\\n    //Done\\\\n    return encryptedFrame;\\\\n  }\\\\n\\\\n  async setSigningKey(key)\\\\n  {\\\\n    //Create new singing key\\\\n    this.signingKey = await EcdsaSignKey.create(key);\\\\n  }\\\\n\\\\n  async setEncryptionKey(key)\\\\n  {\\\\n    //Create new encryption key\\\\n    this.key = await AesCm128HmacSha256EncryptionKey.create(key);\\\\n  }\\\\n\\\\n  async ratchetEncryptionKey()\\\\n  {\\\\n    //Check we have a valid key\\\\n    if (!this.key)\\\\n      throw Error(\\\\\\\"Encryption key not set\\\\\\\");\\\\n\\\\n    //Rachet the key and store it\\\\n    this.key = await this.key.ratchet();\\\\n  }\\\\n};\\\\n\\\\n\\\\nclass EcdsaVerifyKey\\\\n{\\\\n  async setKey(pubKey)\\\\n  {\\\\n    //If it is a crypto key already\\\\n    if (pubKey instanceof CryptoKey)\\\\n    {\\\\n      //Check\\\\n      if (pubKey.algorithm.name!=\\\\\\\"ECDSA\\\\\\\" || !pubKey.usages.includes(\\\\\\\"verify\\\\\\\"))\\\\n        //Error\\\\n        throw new Error(\\\\\\\"Invalid key\\\\\\\");\\\\n      //Set it\\\\n      this.pubKey = pubKey;\\\\n    } else {\\\\n      //Import it\\\\n      this.pubKey = await crypto.subtle.importKey(\\\\n        \\\\\\\"raw\\\\\\\",\\\\n        pubKey,\\\\n        {\\\\n          name\\\\t\\\\t: \\\\\\\"ECDSA\\\\\\\",\\\\n          namedCurve\\\\t: \\\\\\\"P-521\\\\\\\"\\\\n        },\\\\n        false,\\\\n        [\\\\\\\"verify\\\\\\\"]\\\\n      );\\\\n    }\\\\n  }\\\\n\\\\n  async verify(signed,signature)\\\\n  {\\\\n    //Verify\\\\n    return await crypto.subtle.verify(\\\\n      {\\\\n        name: \\\\\\\"ECDSA\\\\\\\",\\\\n        hash: \\\\\\\"SHA-512\\\\\\\"\\\\n      },\\\\n      this.pubKey,\\\\n      signature,\\\\n      signed\\\\n    );\\\\n  }\\\\n\\\\n  static getSignatureLen()\\\\n  {\\\\n    return 64;\\\\n  }\\\\n\\\\n  static async create(pubKey)\\\\n  {\\\\n    //Craete key\\\\n    const key = new EcdsaVerifyKey();\\\\n    //Set key\\\\n    await key.setKey(pubKey);\\\\n    //Done\\\\n    return key;\\\\n\\\\n  }\\\\n};\\\\n\\\\nconst MaxRachetAttemtps = 5;\\\\nconst ReplayWindow = 128;\\\\nconst KeyTimeout = 1000;\\\\n\\\\nclass Receiver\\\\n{\\\\n  constructor(senderId)\\\\n  {\\\\n    //Check keyId\\\\n    Header.checkKeyId(senderId);\\\\n\\\\n    //Store sender id\\\\n    this.senderId = senderId;\\\\n    //Last received counter\\\\n    this.maxReceivedCounter = -1;\\\\n    //Number or ratchets of current key\\\\n    this.numKeyRatchets = 0;\\\\n    //Create keyring\\\\n    this.keyring = [];\\\\n    //Pending verified tags\\\\n    this.pending = new Map();\\\\n\\\\n    //Scheduled keys\\\\n    this.scheduledKeys = new WeakSet ();\\\\n\\\\n    //Function to clear up keys up to given one\\\\n    this.schedulePreviousKeysTimeout = (key) =>{\\\\n      //If this is the only key\\\\n      if (this.keyring.length==1 && this.keyring[0]===key)\\\\n        //Do nothing\\\\n        return;\\\\n      //If has been already scheduled\\\\n      if (this.scheduledKeys.has(key))\\\\n        //Not do it twice\\\\n        return;\\\\n      //Add it\\\\n      this.scheduledKeys.add(key);\\\\n      //Schedule key timeout of previous keys\\\\n      setTimeout(()=>{\\\\n        //Find key index\\\\n        const i = this.keyring.findIndex(k=>k===key);\\\\n        //Remove previous keys\\\\n        this.keyring = this.keyring.splice(i);\\\\n      }, KeyTimeout);\\\\n    };\\\\n  }\\\\n\\\\n  async decrypt(type, ssrcId, header, encryptedFrame, skip)\\\\n  {\\\\n    let authTag, payload, extrabytes = 0, signature, signed;\\\\n    const prevAuthTags = [];\\\\n\\\\n    // console.warn('BOO: BigWorker.Receiver: decrypt');\\\\n    //convert if needed\\\\n    if (!(encryptedFrame instanceof Uint8Array))\\\\n      encryptedFrame = new Uint8Array (encryptedFrame);\\\\n\\\\n    //Replay attack protection\\\\n    if (header.counter<this.maxReceivedCounter && this.maxReceivedCounter-header.counter>ReplayWindow)\\\\n      //Error\\\\n      throw new Error(\\\\\\\"Replay check failed, frame counter too old\\\\\\\");\\\\n\\\\n    //Check if frame contains signature\\\\n    if (header.signature)\\\\n    {\\\\n      //Start from the end\\\\n      let end = encryptedFrame.byteLength;\\\\n\\\\n      //Get lengths\\\\n      const singatureLength = ECDSAVerifyKey.getSignatureLen();\\\\n      const authTagLength   = AesCm128HmacSha256EncryptionKey.getAuthTagLen(type);\\\\n\\\\n      //Get signature\\\\n      signature = encryptedFrame.subarray(end - singatureLength, end);\\\\n      //Move backward\\\\n      end -= singatureLength;\\\\n\\\\n      //Get number of tags\\\\n      const num = encryptedFrame[end--];\\\\n\\\\n      //Read all tags\\\\n      for (let i=0; i<num; ++i)\\\\n      {\\\\n        //Get previous tag\\\\n        const prevTag = encryptedFrame.subarray(end - authTagLength, end);\\\\n        //Move backward\\\\n        end -= authTagLength;\\\\n        //Add tag to previous tags in hex\\\\n        prevAuthTags.push(Utils.toHex(prevTag))\\\\n      }\\\\n      //Get the extra bytes\\\\n      extrabytes = encryptedFrame.byteLength - end;\\\\n\\\\n      //Move backward to start oth current frame auth tag\\\\n      end -= authTagLength;\\\\n\\\\n      //Get singed part\\\\n      signed = encryptedFrame.subarray(end, encryptedFrame.byteLength - singatureLength)\\\\n    }\\\\n\\\\n    //For each key in key ring\\\\n    for (let i=0;i<this.keyring.length;++i)\\\\n    {\\\\n      //Get key from ring\\\\n      const key = this.keyring[i];\\\\n      try {\\\\n        //Try to decrypt payload\\\\n        [payload, authTag] = await key.decrypt(type, header, encryptedFrame, extrabytes, skip);\\\\n        //Done\\\\n        break;\\\\n      } catch(e) {\\\\n\\\\n      }\\\\n    }\\\\n\\\\n    //If not found yet\\\\n    if (!payload)\\\\n    {\\\\n      //Get last key\\\\n      let key = this.keyring[this.keyring.length-1];\\\\n\\\\n      //Try ractchet last key\\\\n      for (let i=this.numKeyRatchets; i<MaxRachetAttemtps; ++i)\\\\n      {\\\\n        //Rachet key\\\\n        key = await key.ratchet();\\\\n\\\\n        //Append to the keyring\\\\n        this.keyring.push(key);\\\\n\\\\n        try {\\\\n          //Try to decrypt payload\\\\n          [payload, authTag] = await key.decrypt(type, header, encryptedFrame, extrabytes, skip);\\\\n          //Activate\\\\n          this.schedulePreviousKeysTimeout(key);\\\\n          //Done\\\\n          break;\\\\n        } catch(e) {\\\\n\\\\n        }\\\\n      }\\\\n    }\\\\n\\\\n    //Last check\\\\n    if (!payload)\\\\n      //Decryption failed\\\\n      throw new Error(\\\\\\\"Decryption failed\\\\\\\");\\\\n\\\\n    //If we are sending part of the frame in clear\\\\n    if (skip)\\\\n      //Copy skiped payload\\\\n      payload.set(encryptedFrame.subarray(0,skip),0);\\\\n\\\\n    //Check if have received anything from this ssrc before\\\\n    if (!this.pending.has(ssrcId))\\\\n      //Add it\\\\n      this.pending.set(ssrcId,new Set());\\\\n\\\\n    //Get pending list\\\\n    const pending = this.pending.get(ssrcId);\\\\n\\\\n    //Check if it constains signatures\\\\n    if (header.signed)\\\\n    {\\\\n      //try to verify list\\\\n      if (!await this.verifyKey.verify(signed,signature))\\\\n        //Error\\\\n        throw new Error(\\\\\\\"Could not verify signature\\\\\\\");\\\\n      //For each signed tag\\\\n      for (const tag in prevAuthTags)\\\\n        //Delete from pending to be verified tags\\\\n        pending.delete(tag);\\\\n    } else {\\\\n      //Push this tag to\\\\n      pending.add(Utils.toHex(authTag));\\\\n    }\\\\n\\\\n    //Set authenticated sender id and frame Id\\\\n    payload.senderId = header.keyId;\\\\n    payload.frameId  = header.counter;\\\\n\\\\n    //Store last received counter\\\\n    this.maxReceivedCounter = Math.max(header.counter, this.maxReceivedCounter);\\\\n\\\\n    //Return decrypted payload\\\\n    return payload;\\\\n  }\\\\n\\\\n  async setVerifyKey(key)\\\\n  {\\\\n    //Create new singing key\\\\n    this.verifyKey = EcdsaVerifyKey.create(key);\\\\n  }\\\\n\\\\n  async setEncryptionKey(raw)\\\\n  {\\\\n    //Create new encryption key\\\\n    const key = await AesCm128HmacSha256EncryptionKey.create(raw);\\\\n    //Append to the keyring\\\\n    this.keyring.push(key);\\\\n    //Restart ratchet count number\\\\n    this.numKeyRatchets = 0;\\\\n    //Activate\\\\n    this.schedulePreviousKeysTimeout(key);\\\\n  }\\\\n};\\\\n\\\\nclass Context\\\\n{\\\\n\\\\n  constructor(senderId, config)\\\\n  {\\\\n    //Store config\\\\n    this.config = Object.assign({}, config);\\\\n    //Only one sender per context\\\\n    this.sender = new Sender(senderId);\\\\n\\\\n    //The map of known remote senders\\\\n    this.receivers = new Map();\\\\n  }\\\\n\\\\n  isSkippingVp8PayloadHeader()\\\\n  {\\\\n    return !!this.config.skipVp8PayloadHeader;\\\\n  }\\\\n\\\\n  async setSenderEncryptionKey(key)\\\\n  {\\\\n    //Set it\\\\n    return this.sender.setEncryptionKey(key);\\\\n  }\\\\n\\\\n  async ratchetSenderEncryptionKey()\\\\n  {\\\\n    //Set it\\\\n    return this.sender.ratchetEncryptionKey();\\\\n  }\\\\n\\\\n  async setSenderSigningKey(key)\\\\n  {\\\\n    //Set it\\\\n    return this.sender.setSigningKey(key);\\\\n  }\\\\n\\\\n  addReceiver(receiverkKeyId)\\\\n  {\\\\n    console.warn('BOO: addReceiver');\\\\n    //Check we don't have a receiver already for that id\\\\n    if(this.receivers.has(receiverkKeyId)) {\\\\n      console.warn('BOO: ... error');\\\\n      //Error\\\\n      throw new Error(\\\\\\\"There was already a receiver for keyId \\\\\\\"+receiverkKeyId);\\\\n    }\\\\n\\\\n    //Add new\\\\n    this.receivers.set(receiverkKeyId, new Receiver(receiverkKeyId));\\\\n    console.warn('BOO: ... done addReceiver');\\\\n  }\\\\n\\\\n  async setReceiverEncryptionKey(receiverkKeyId, key)\\\\n  {\\\\n    console.warn('BOO: setReceiverEncryptionKey');\\\\n    //Get receiver for the sender\\\\n    const receiver = this.receivers.get(receiverkKeyId);\\\\n\\\\n    //IF not found\\\\n    if (!receiver) {\\\\n      console.warn('BOO: ... error');\\\\n      //Error\\\\n      throw new Error(\\\\\\\"No receiver found for keyId \\\\\\\"+receiverkKeyId);\\\\n    }\\\\n\\\\n    //Rachet\\\\n    const status = await receiver.setEncryptionKey(key);\\\\n    console.warn(`BOO: ${status}`);\\\\n\\\\n    console.warn('BOO: done');\\\\n    return status;\\\\n  }\\\\n\\\\n  async setReceiverVerifyKey(receiverkKeyId,key)\\\\n  {\\\\n    console.warn('BOO: setReceiverVerifyKey');\\\\n    //Get receiver for the sender\\\\n    const receiver = this.receivers.get(receiverkKeyId);\\\\n\\\\n    //IF not found\\\\n    if (!receiver) {\\\\n      console.warn('BOO: error');\\\\n      //Error\\\\n      throw new Error(\\\\\\\"No receiver found for keyId \\\\\\\"+receiverkKeyId);\\\\n    }\\\\n\\\\n    //Rachet\\\\n    const status = await receiver.setVerifyKey(key);\\\\n    console.warn(`BOO: status ${status}`);\\\\n\\\\n    console.warn('BOO: done');\\\\n    return status;\\\\n  }\\\\n\\\\n  deleteReceiver(receiverkKeyId)\\\\n  {\\\\n    //Delete receiver\\\\n    return this.receivers.delete(receiverkKeyId);\\\\n  }\\\\n\\\\n  async encrypt(type, ssrcId, frame, skip)\\\\n  {\\\\n    //Encrypt it\\\\n    return this.sender.encrypt(type, ssrcId, frame, skip);\\\\n  }\\\\n\\\\n  async decrypt(type, ssrcId, encryptedFrame, skip)\\\\n  {\\\\n    //convert if needed\\\\n    if (!(encryptedFrame instanceof Uint8Array))\\\\n      encryptedFrame = new Uint8Array (encryptedFrame);\\\\n\\\\n    //Parse encrypted payload\\\\n    const header = Header.parse(encryptedFrame.subarray(skip));\\\\n\\\\n    //Get receiver for the sender\\\\n    const receiver = this.receivers.get(header.keyId);\\\\n\\\\n    //IF not found\\\\n    if (!receiver)\\\\n      //Error\\\\n      throw new Error(\\\\\\\"No receiver found for keyId \\\\\\\" + header.keyId);\\\\n\\\\n    //Decrypt it\\\\n    return receiver.decrypt(type, ssrcId, header, encryptedFrame, skip);\\\\n  }\\\\n\\\\n};\\\\n\\\\n\\\\nconst VP8PayloadHeader = {\\\\n\\\\n  parse : function(buffer)\\\\n  {\\\\n    //Check size\\\\n    if (buffer.byteLength<3)\\\\n      //Invalid\\\\n      return null;\\\\n\\\\n    //Create uint view\\\\n    const view = new Uint8Array(buffer);\\\\n\\\\n    //Read comon 3 bytes\\\\n    //   0 1 2 3 4 5 6 7\\\\n    //  +-+-+-+-+-+-+-+-+\\\\n    //  |Size0|H| VER |P|\\\\n    //  +-+-+-+-+-+-+-+-+\\\\n    //  |     Size1     |\\\\n    //  +-+-+-+-+-+-+-+-+\\\\n    //  |     Size2     |\\\\n    //  +-+-+-+-+-+-+-+-+\\\\n    const firstPartitionSize\\\\t= view[0] >> 5;\\\\n    const showFrame\\\\t\\\\t\\\\t= view[0] >> 4 & 0x01;\\\\n    const version\\\\t\\\\t\\\\t= view[0] >> 1 & 0x07;\\\\n    const isKeyFrame\\\\t\\\\t= (view[0] & 0x01) == 0;\\\\n\\\\n    //check if more\\\\n    if (isKeyFrame)\\\\n    {\\\\n      //Check size\\\\n      if (buffer.byteLength<10)\\\\n        //Invalid\\\\n        return null;\\\\n      //Get size in le\\\\n      const hor = view[7]<<8 | view[6];\\\\n      const ver = view[9]<<8 | view[8];\\\\n      //Get dimensions and scale\\\\n      const width\\\\t\\\\t= hor & 0x3fff;\\\\n      const horizontalScale   = hor >> 14;\\\\n      const height\\\\t\\\\t= ver & 0x3fff;\\\\n      const verticalScale\\\\t= ver >> 14;\\\\n      //Key frame\\\\n      return view.subarray (0,10);\\\\n    }\\\\n\\\\n    //No key frame\\\\n    return view.subarray (0,3);\\\\n  }\\\\n};\\\\n\\\\nclass TaskQueue\\\\n{\\\\n  constructor()\\\\n  {\\\\n    this.tasks = [];\\\\n    this.running = false;\\\\n  }\\\\n\\\\n  enqueue(promise,callback,error)\\\\n  {\\\\n    //enqueue task\\\\n    this.tasks.push({promise,callback,error});\\\\n    //Try run\\\\n    this.run();\\\\n  }\\\\n\\\\n  async run()\\\\n  {\\\\n    //If already running\\\\n    if (this.running)\\\\n      //Nothing\\\\n      return;\\\\n    //Running\\\\n    this.running = true;\\\\n    //Run all pending tasks\\\\n    while(this.tasks.length)\\\\n    {\\\\n      try {\\\\n        //Wait for first promise to finish\\\\n        const result = await this.tasks[0].promise;\\\\n        //Run callback\\\\n        this.tasks[0].callback(result);\\\\n      } catch(e) {\\\\n        //Run error callback\\\\n        this.tasks[0].error(e);\\\\n      }\\\\n      //Remove task from queue\\\\n      this.tasks.shift();\\\\n    }\\\\n    //Ended\\\\n    this.running = false;\\\\n  }\\\\n}\\\\nlet context;\\\\n\\\\nonmessage = async (event) => {\\\\n  //Get data\\\\n  const {transId,cmd,args} = event.data;\\\\n\\\\n  try {\\\\n    let result = true;\\\\n\\\\n    console.warn(`BOO: ***** BigWorker cmd ${event.data.cmd}`);\\\\n    //Depending on the cmd\\\\n    switch(event.data.cmd)\\\\n    {\\\\n      case \\\\\\\"init\\\\\\\":\\\\n      {\\\\n        console.warn('BOO: init');\\\\n        //Get info\\\\n        const {senderId, config} = args;\\\\n        //Crate context\\\\n        context = new Context(senderId, config);\\\\n        break;\\\\n      }\\\\n      case \\\\\\\"encrypt\\\\\\\":\\\\n      {\\\\n        console.warn('BOO: encrypt');\\\\n        //The recrypt queue\\\\n        const tasks = new TaskQueue();\\\\n        //Get event data\\\\n        // const{id, kind, readableStream, writableStream} = args;\\\\n        const{id, kind, stream} = args;\\\\n        //Create transform stream foo encrypting\\\\n        const transformStream = new TransformStream({\\\\n          transform: async (chunk, controller)=>{\\\\n            //Nothing in clear\\\\n            let skip = 0;\\\\n            //Check if it is video and we are skipping vp8 payload header\\\\n            if (kind==\\\\\\\"video\\\\\\\" && context.isSkippingVp8PayloadHeader())\\\\n            {\\\\n              //Get VP8 header\\\\n              const vp8 = VP8PayloadHeader.parse(chunk.data);\\\\n              //Skip it\\\\n              skip = vp8.byteLength;\\\\n            }\\\\n            //Enqueue task\\\\n            tasks.enqueue (\\\\n              context.encrypt(kind, id, chunk.data, skip),\\\\n              (encrypted) => {\\\\n                //Set back encrypted payload\\\\n                chunk.data = encrypted.buffer;\\\\n                //write back\\\\n                controller.enqueue(chunk);\\\\n              },\\\\n              (error)=>{\\\\n                //TODO: handle errors\\\\n                console.warn(`BOO: encrypting error ${error}`);\\\\n              }\\\\n            );\\\\n          }\\\\n        });\\\\n        //Encrypt\\\\n        // readableStream\\\\n        try {\\\\n          stream.readable\\\\n            .pipeThrough(transformStream)\\\\n          // .pipeTo(writableStream);\\\\n            .pipeTo(stream.writable);\\\\n        } catch (err) {\\\\n          console.warn(`BOO: more encrypting errors ${err}`);\\\\n        }\\\\n        break;\\\\n      }\\\\n      case \\\\\\\"decrypt\\\\\\\":\\\\n      {\\\\n        console.warn('decrypt');\\\\n        //The recrypt queue\\\\n        const tasks = new TaskQueue();\\\\n        //Last reveiced senderId\\\\n        let senderId = -1;\\\\n        //Get event data\\\\n        // const{id, kind, readableStream, writableStream} = args;\\\\n        const{id, kind, stream} = args;\\\\n        //Create transform stream for encrypting\\\\n        const transformStream = new TransformStream({\\\\n          transform: async (chunk, controller)=>{\\\\n            //Nothing in clear\\\\n            let skip = 0;\\\\n            //Check if it is video and we are skipping vp8 payload header\\\\n            if (kind==\\\\\\\"video\\\\\\\" && context.isSkippingVp8PayloadHeader())\\\\n            {\\\\n              //Get VP8 header\\\\n              const vp8 = VP8PayloadHeader.parse(chunk.data);\\\\n              //Skip it\\\\n              skip = vp8.byteLength;\\\\n            }\\\\n            //Enqueue task\\\\n            tasks.enqueue (\\\\n              context.decrypt(kind, id, chunk.data, skip),\\\\n              (decrypted) => {\\\\n                //Set back decrypted payload\\\\n                chunk.data = decrypted.buffer;\\\\n                //write back\\\\n                controller.enqueue(chunk);\\\\n                //If it is a sender\\\\n                if (decrypted.senderId!=senderId)\\\\n                {\\\\n                  //Store it\\\\n                  senderId = decrypted.senderId;\\\\n                  //Launch event\\\\n                  postMessage ({event: {\\\\n                    name\\\\t: \\\\\\\"authenticated\\\\\\\",\\\\n                    data\\\\t: {\\\\n                      id\\\\t : id,\\\\n                      senderId : senderId\\\\n                    }\\\\n                  }});\\\\n                }\\\\n              },\\\\n              (error)=>{\\\\n                //TODO: handle errors\\\\n                // console.warn(`BOO: decrypting error ${error}`);\\\\n              }\\\\n            );\\\\n          }\\\\n        });\\\\n        //Decrypt\\\\n        // readableStream\\\\n        //   .pipeThrough(transformStream)\\\\n        //   .pipeTo(writableStream);\\\\n        try {\\\\n          stream.readable\\\\n            .pipeThrough(transformStream)\\\\n            .pipeTo(stream.writable);\\\\n        } catch (err) {\\\\n          console.warn(`BOO: more decrypting errors ${err}`);\\\\n        }\\\\n        break;\\\\n      }\\\\n      default:\\\\n      //Excute \\\\\\\"cmd\\\\\\\" method on context\\\\n      result = await context[cmd](...args || []);\\\\n    }\\\\n    //Send result back\\\\n    postMessage ({transId,result});\\\\n  } catch (error) {\\\\n    console.error(error);\\\\n    //Send error back\\\\n    postMessage({transId,error});\\\\n  }\\\\n};\\\\n\\\\n\\\\n//# sourceURL=webpack://sframe/./lib/sframe.worker.js?\\\");\\n\\n/***/ })\\n\\n/******/ });\", \"Worker\", undefined, __webpack_require__.p + \"bundle.worker.js\");\n}\n\n\n//# sourceURL=webpack://sframe/./lib/sframe.worker.js?");

/***/ }),

/***/ "./node_modules/worker-loader/dist/runtime/inline.js":
/*!***********************************************************!*\
  !*** ./node_modules/worker-loader/dist/runtime/inline.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};\n\n//# sourceURL=webpack://sframe/./node_modules/worker-loader/dist/runtime/inline.js?");

/***/ })

/******/ });
});