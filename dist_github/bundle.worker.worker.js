/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/sframe.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/sframe.worker.js":
/*!******************************!*\
  !*** ./lib/sframe.worker.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n  0 1 2 3 4 5 6 7\n  +-+-+-+-+-+-+-+-+\n  |S|LEN  |X|  K  |\n  +-+-+-+-+-+-+-+-+\n  SFrame header metadata\n\n  Signature flag (S): 1 bit This field indicates the payload contains a signature of set. Counter Length (LEN): 3 bits This field indicates the length of the CTR fields in bytes. Extended Key Id Flag (X): 1 bit\n  Indicates if the key field contains the key id or the key length. Key or Key Length: 3 bits This field contains the key id (KID) if the X flag is set to 0, or the key length (KLEN) if set to 1.\n\n  If X flag is 0 then the KID is in the range of 0-7 and the frame counter (CTR) is found in the next LEN bytes:\n\n  0 1 2 3 4 5 6 7\n  +-+-+-+-+-+-+-+-+---------------------------------+\n  |S|LEN  |0| KID |    CTR... (length=LEN)          |\n  +-+-+-+-+-+-+-+-+---------------------------------+\n  Key id (KID): 3 bits The key id (0-7). Frame counter (CTR): (Variable length) Frame counter value up to 8 bytes long.\n\n  if X flag is 1 then KLEN is the length of the key (KID), that is found after the SFrame header metadata byte. After the key id (KID), the frame counter (CTR) will be found in the next LEN bytes:\n\n  0 1 2 3 4 5 6 7\n  +-+-+-+-+-+-+-+-+---------------------------+---------------------------+\n  |S|LEN  |1|KLEN |   KID... (length=KLEN)    |    CTR... (length=LEN)    |\n  +-+-+-+-+-+-+-+-+---------------------------+---------------------------+\n*/\nconst Header = {\n\n  parse : function(buffer)\n  {\n    //Create uint view\n    const view = new Uint8Array(buffer);\n\n    //Get metadata\n    const metadata = view[0];\n\n    //Get values\n    const s\t\t= !!(metadata & 0x80);\n    const len\t= (metadata >> 4) & 0x07;\n    const x\t\t= !!(metadata & 0x08);\n    const k\t\t= metadata & 0x07;\n\n    //Get key id\n    let keyId = 0;\n    //Check if it is the extented key format\n    if (x)\n    {\n      //Read length\n      for (let i=0;i<k;i++)\n        keyId = (keyId * 256) + view[i+1];\n    } else {\n      //Short version\n      keyId = k;\n    }\n\n    //Get ctr\n    const ini = x ? k + 1 : 1;\n    let counter = 0;\n    //Read length\n    for (let i=0;i<len;i++)\n      counter = (counter * 256) + view[ini+i];\n\n    //Get header buffer view\n    const header = view.subarray(0, x ? k + len + 1 : len + 1);\n\n    //Add parsed atributes\n    header.signature   = s;\n    header.keyId\t   = keyId;\n    header.counter\t   = counter;\n\n    //Done\n    return header;\n  },\n  generate: function(signature,keyId,counter)\n  {\n    //Check keyId\n    Header.checkKeyId(keyId);\n\n    //Calcultate variavle length\n    const varlen = (x) => x ? parseInt(Math.log(x) / Math.log(256))+1 : 1;\n\n    //Get key extension and length\n    const x = keyId > 7;\n    const k = x ? varlen(keyId) : keyId;\n\n    //Get counter length\n    const len = varlen(counter);\n\n    //Ensure counter is not huge\n    if (len>7)\n      //Error\n      throw new Error(\"Counter is too big\");\n\n    //Generate header\n    const header = new Uint8Array( x ? 1 + k + len : 1 + len);\n\n    //Set metadata header\n    header[0] = !!signature;\n    header[0] = header[0] << 3  | ( len & 0x07);\n    header[0] = header[0] << 1  | x;\n    header[0] = header[0] << 3  | ( k & 0x07);\n\n    //Add parsed atributes\n    header.signature   = !!signature;\n    header.keyId\t   = keyId;\n    header.counter\t   = counter;\n\n    //If extended key\n    if (x)\n      //Add key id\n      for (let i=0; i<k; ++i)\n        header[i+1] = (keyId >> (k-1-i)*8) & 0xff;\n    //The coutner init\n    const ini = x ? k + 1 : 1;\n    //Add counter\n    for (let i=0; i<len; ++i)\n      header[ini+i] = (counter >> (len-1-i)*8) & 0xff;\n\n\n    //Done\n    return header;\n  }\n};\n\nHeader.MaxKeyId = 0xFFFFFFFFFF;\n\nHeader.checkKeyId = function(keyId)\n{\n  //Check it is possitive\n  if (keyId<0)\n    //Error\n    throw new Error(\"keyId must be possitive\");\n  //Check it is possitive\n  if (keyId>Header.MaxKeyId)\n    //Error\n    throw new Error(\"keyId must be 5 bytes long at most\");\n};\n\n//TODO: Update to Ed25519 when available\n// https://chromestatus.com/features/4913922408710144\n// https://chromium.googlesource.com/chromium/src/+log/master/components/webcrypto/algorithms/ed25519.cc\n\nclass EcdsaSignKey\n{\n\n  async setKey(privKey)\n  {\n    //If it is a crypto key already\n    if (privKey instanceof CryptoKey)\n    {\n      //Check private key algorithm\n      if (privKey.algorithm.name!=\"ECDSA\" || !privKey.usages.includes(\"sign\"))\n        //Error\n        throw new Error(\"Invalid key\");\n      //Set it\n      this.privKey = privKey;\n    } else {\n      //Import it\n      this.privKey = await crypto.subtle.importKey(\n        \"pkcs8\",\n        privKey,\n        {\n          name\t\t: \"ECDSA\",\n          namedCurve\t: \"P-521\"\n        },\n        false,\n        [\"sign\"]\n      );\n    }\n  }\n\n  async sign(authTags)\n  {\n    //Verify\n    return new Uint8Array(await crypto.subtle.sign(\n      {\n        name: \"ECDSA\",\n        hash: \"SHA-512\"\n      },\n      this.privKey,\n      authTags\n    ));\n  }\n\n  static getSignatureLen()\n  {\n    return 64;\n  }\n\n  static async create(privKey)\n  {\n    //Craete key\n    const key = new EcdsaSignKey();\n    //Set key\n    await key.setKey(privKey);\n    //Done\n    return key;\n\n  }\n};\n\nconst Utils =\n  {\n    toHex : function(buffer)\n    {\n      return Array.prototype.map.call(buffer instanceof Uint8Array ? buffer : new Uint8Array (buffer), x =>x.toString(16).padStart(2,\"0\")).join(\"\");\n    },\n    fromHex: function(str)\n    {\n      const bytes = [];\n      for (let i=0;i<str.length/2;++i)\n        bytes.push(parseInt(str.substring(i*2, (i+1)*2), 16));\n\n      return new Uint8Array(bytes);\n    },\n    equals : function(a,b)\n    {\n      if (a.byteLength != b.byteLength) return false;\n      for (let i = 0 ; i != a.byteLength ; i++)\n        if (a[i] != b[i]) return false;\n      return true;\n    }\n  };\n\nconst textEncoder = new TextEncoder()\n\nconst Salts =  {\n  \"SaltKey\"\t\t: textEncoder.encode(\"SFrameSaltKey\"),\n  \"EncryptionKey\"\t\t: textEncoder.encode(\"SFrameEncryptionKey\"),\n  \"AuthenticationKey\"\t: textEncoder.encode(\"SFrameAuthenticationKey\"),\n  \"RatchetKey\"\t\t: textEncoder.encode(\"SFrameRatchetKey\")\n};\n\nconst IV =\n  {\n    generate : function(keyId,counter,salt)\n    {\n      //128 bits\n      const iv = new Uint8Array (16);\n      //Get view\n      const view = new DataView(iv.buffer);\n      //Set keyId\n      view.setBigUint64(0, BigInt(counter));\n      //Set coutner\n      view.setBigUint64(8, BigInt(keyId));\n      //Xor with salt key\n      for (let i=0; i<iv.byteLength; ++i)\n        //xor\n        view.setUint8(i,iv[i]^salt[i]);\n      //return buffer\n      return iv;\n    }\n  };\n\nclass AesCm128HmacSha256EncryptionKey\n{\n  async setKey(key)\n  {\n    if (key instanceof CryptoKey)\n    {\n      //Check private key algorithm\n      if (key.algorithm.name!=\"HKDF\")\n        //Error\n        throw new Error(\"Invalid key\");\n    } else {\n      //Import key\n      key = await crypto.subtle.importKey(\n        \"raw\",\n        key,\n        \"HKDF\",\n        false,\n        [\"deriveBits\", \"deriveKey\"]\n      );\n    }\n\n    //Get salt key\n    this.saltKey = new Uint8Array(await crypto.subtle.deriveBits(\n      {\n        name : \"HKDF\",\n        hash : \"SHA-256\",\n        salt : Salts.SaltKey,\n        info : new ArrayBuffer()\n      },\n      key,\n      128\n    ));\n\n    //Get encryption key\n    this.encryptionKey = await crypto.subtle.deriveKey(\n      {\n        name : \"HKDF\",\n        hash : \"SHA-256\",\n        salt : Salts.EncryptionKey,\n        info : new ArrayBuffer()\n      },\n      key,\n      {\n        name : \"AES-CTR\",\n        length : 128\n      },\n      false,\n      [\"encrypt\",\"decrypt\"]\n    );\n\n    //Get authentication key\n    this.authKey = await crypto.subtle.deriveKey(\n      {\n        name : \"HKDF\",\n        hash : \"SHA-256\",\n        salt : Salts.AuthenticationKey,\n        info : new ArrayBuffer()\n      },\n      key,\n      {\n        name : \"HMAC\",\n        hash : \"SHA-256\",\n        length : 256\n      },\n      false,\n      [\"sign\",\"verify\"]\n    );\n\n    //Derive Ratchet key\n    this.ratchetKey = await crypto.subtle.deriveBits(\n      {\n        name : \"HKDF\",\n        hash : \"SHA-256\",\n        salt : Salts.RatchetKey,\n        info : new ArrayBuffer()\n      },\n      key,\n      256\n    );\n  }\n\n  async encrypt(type,header,payload,extraBytes,skip)\n  {\n    //Encure int\n    skip = skip ? skip : 0;\n\n    //Create IV\n    const iv = IV.generate(header.keyId, header.counter, this.saltKey);\n\n    //Encrypt\n    const encrypted = await crypto.subtle.encrypt(\n      {\n        name\t: \"AES-CTR\",\n        counter : iv,\n        length  : 128\n      },\n      this.encryptionKey,\n      payload\n    );\n\n    //Get auth tag length from media type\n    const authTagLength = AesCm128HmacSha256EncryptionKey.getAuthTagLen(type);\n\n    //Create encrypted frame\n    const encryptedFrame = new Uint8Array(header.byteLength + payload.byteLength + authTagLength + extraBytes + skip);\n\n    //Set header and encrypted payolad\n    encryptedFrame.set(header, skip);\n    encryptedFrame.set(new Uint8Array(encrypted), skip + header.length);\n\n    //Authenticate\n    const signature = new Uint8Array(await crypto.subtle.sign(\n      \"HMAC\",\n      this.authKey,\n      encryptedFrame.subarray(skip, skip + header.byteLength + encrypted.byteLength)\n    ));\n\n    //Truncate\n    const authTag = signature.subarray(0, authTagLength);\n\n    //Append authentication tag\n    encryptedFrame.set(authTag, skip + encrypted.byteLength + header.byteLength );\n\n    //Done\n    return [encryptedFrame,authTag];\n\n  }\n\n  async decrypt(type, header, encryptedFrame, extrabytes, skip)\n  {\n    //Encure int\n    skip = skip ? skip : 0;\n\n    //Create IV\n    const iv = IV.generate(header.keyId, header.counter, this.saltKey);\n\n    //Get auth tag length from media type\n    const authTagLength = AesCm128HmacSha256EncryptionKey.getAuthTagLen(type);\n\n    //Get encrypted frame length (without extra bytes from signature)\n    const frameLength = encryptedFrame.byteLength - extrabytes - skip;\n\n    //Get authentication tag\n    const authTag = encryptedFrame.subarray(skip + frameLength - authTagLength, skip + frameLength);\n\n    //Get encrypted payload\n    const encrypted = encryptedFrame.subarray(skip + header.byteLength, skip + frameLength - authTagLength);\n\n    //Calculate signature\n    const signature = new Uint8Array(await crypto.subtle.sign(\n      \"HMAC\",\n      this.authKey,\n      encryptedFrame.subarray(skip, skip + header.byteLength + encrypted.byteLength)\n    ));\n\n    //Authenticate authTag\n    let authenticated = true;\n    //Avoid timimg attacks by iterating over all bytes\n    for (let i=0;i<authTagLength;++i)\n      //check signature\n      authenticated &= authTag[i]===signature[i];\n\n    //If not all where equal\n    if (!authenticated)\n      //Authentication error\n      throw new Error(\"Authentication error\");\n\n    //Decrypt\n    const payload = new Uint8Array (await crypto.subtle.decrypt(\n      {\n        name\t: \"AES-CTR\",\n        counter : iv,\n        length  : 128\n      },\n      this.encryptionKey,\n      encrypted\n    ));\n\n    //Done\n    return [payload, authTag];\n  }\n\n  async ratchet()\n  {\n    //Create new key\n    const key = new AesCm128HmacSha256EncryptionKey();\n\n    //Set ratchet key\n    await key.setKey(this.ratchetKey);\n\n    //Done\n    return key;\n  }\n\n  static getAuthTagLen(type)\n  {\n    return type.toLowerCase()===\"video\" ? 10 : 4;\n  };\n\n  static async create(raw)\n  {\n    //Create new key\n    const key = new AesCm128HmacSha256EncryptionKey();\n    //Set raw key\n    await key.setKey(raw);\n    //Done\n    return key;\n  }\n};\n\n\nconst SigningFrameInterval = 10;\n\nclass Sender\n{\n  constructor(senderId)\n  {\n    //Check keyId\n    Header.checkKeyId(senderId);\n\n    //The global frame counter\n    this.counter = 0;\n\n    //Store senderId/keyId\n    this.senderId = senderId;\n\n    //Pending frames for signing\n    this.pending = new Map();\n  }\n\n  async encrypt(type, ssrcId, payload, skip)\n  {\n    // console.warn('BOO: BigWorker.Sender: encrypt');\n    //Check we have a valid key\n    if (!this.key)\n      throw Error(\"Encryption key not set\");\n\n    //convert if needed\n    if (!(payload instanceof Uint8Array))\n      payload = new Uint8Array (payload);\n\n    //Encure int\n    skip = skip ? skip : 0;\n\n    //Get counter for frame\n    const counter = this.counter++;\n\n    //If we don't have the ssrc\n    if (!this.pending.has(ssrcId))\n      //Create new pending frames array\n      this.pending.set(ssrcId,[]);\n\n    //Get pending frames for signature\n    const pending = this.pending.get(ssrcId);\n\n    //Do we need to sign the frames?\n    const signing = this.signingKey && pending.length > SigningFrameInterval;\n\n    //Get auth tag len for type\n    const authTagLen = AesCm128HmacSha256EncryptionKey.getAuthTagLen(type);\n\n    //Calculae extra bytes\n    const extraBytes = signing ? pending.length * AesCm128HmacSha256EncryptionKey.getAuthTagLen(type) + 1 + EcdsaSignKey.getSignatureLen() : 0;\n\n    //Generate header\n    const header = Header.generate(signing,this.senderId,counter);\n\n    //Encrypt frame\n    const [encryptedFrame,authTag] = await this.key.encrypt(type, header, payload, extraBytes, skip);\n\n    //If we are sending part of the frame in clear\n    if (skip)\n      //Copy skiped payload\n      encryptedFrame.set(payload.subarray(0,skip),0);\n\n    //If we need to sign the frame\n    if (signing)\n    {\n      //Append after auth tag\n      let ini = skip + encryptedFrame.byteLength - extraBytes;\n\n      //Get tag list view\n      const authTags = encryptedFrame.subarray(ini - authTagLen, (pending.length + 1) * authTagLen);\n\n      //Add all previous tags\n      for (const previousTag of pending)\n      {\n        //Append to frame\n        encryptedFrame.set(previousTag, ini);\n        //Move\n        ini += authTagLen;\n      }\n\n      //Add number of bytes\n      encryptedFrame[ini++] = pending.length;\n\n      //Create signature with all auth tags (including this frame's one)\n      const signature = await this.signingKey.sign(authTags);\n\n      //Add signature\n      encryptedFrame.set(signature, ini);\n\n      //Empty pending list\n      this.pending.set(ssrcId,[]);\n\n      //If we can sign\n    } else if (this.signingKey) {\n      //Append a copy of current tag at the begining\n      pending.unshift(authTag.slice());\n    }\n\n    //Set authenticated sender id and frame Id\n    encryptedFrame.senderId = header.keyId;\n    encryptedFrame.frameId  = header.counter;\n\n    //Done\n    return encryptedFrame;\n  }\n\n  async setSigningKey(key)\n  {\n    //Create new singing key\n    this.signingKey = await EcdsaSignKey.create(key);\n  }\n\n  async setEncryptionKey(key)\n  {\n    //Create new encryption key\n    this.key = await AesCm128HmacSha256EncryptionKey.create(key);\n  }\n\n  async ratchetEncryptionKey()\n  {\n    //Check we have a valid key\n    if (!this.key)\n      throw Error(\"Encryption key not set\");\n\n    //Rachet the key and store it\n    this.key = await this.key.ratchet();\n  }\n};\n\n\nclass EcdsaVerifyKey\n{\n  async setKey(pubKey)\n  {\n    //If it is a crypto key already\n    if (pubKey instanceof CryptoKey)\n    {\n      //Check\n      if (pubKey.algorithm.name!=\"ECDSA\" || !pubKey.usages.includes(\"verify\"))\n        //Error\n        throw new Error(\"Invalid key\");\n      //Set it\n      this.pubKey = pubKey;\n    } else {\n      //Import it\n      this.pubKey = await crypto.subtle.importKey(\n        \"raw\",\n        pubKey,\n        {\n          name\t\t: \"ECDSA\",\n          namedCurve\t: \"P-521\"\n        },\n        false,\n        [\"verify\"]\n      );\n    }\n  }\n\n  async verify(signed,signature)\n  {\n    //Verify\n    return await crypto.subtle.verify(\n      {\n        name: \"ECDSA\",\n        hash: \"SHA-512\"\n      },\n      this.pubKey,\n      signature,\n      signed\n    );\n  }\n\n  static getSignatureLen()\n  {\n    return 64;\n  }\n\n  static async create(pubKey)\n  {\n    //Craete key\n    const key = new EcdsaVerifyKey();\n    //Set key\n    await key.setKey(pubKey);\n    //Done\n    return key;\n\n  }\n};\n\nconst MaxRachetAttemtps = 5;\nconst ReplayWindow = 128;\nconst KeyTimeout = 1000;\n\nclass Receiver\n{\n  constructor(senderId)\n  {\n    //Check keyId\n    Header.checkKeyId(senderId);\n\n    //Store sender id\n    this.senderId = senderId;\n    //Last received counter\n    this.maxReceivedCounter = -1;\n    //Number or ratchets of current key\n    this.numKeyRatchets = 0;\n    //Create keyring\n    this.keyring = [];\n    //Pending verified tags\n    this.pending = new Map();\n\n    //Scheduled keys\n    this.scheduledKeys = new WeakSet ();\n\n    //Function to clear up keys up to given one\n    this.schedulePreviousKeysTimeout = (key) =>{\n      //If this is the only key\n      if (this.keyring.length==1 && this.keyring[0]===key)\n        //Do nothing\n        return;\n      //If has been already scheduled\n      if (this.scheduledKeys.has(key))\n        //Not do it twice\n        return;\n      //Add it\n      this.scheduledKeys.add(key);\n      //Schedule key timeout of previous keys\n      setTimeout(()=>{\n        //Find key index\n        const i = this.keyring.findIndex(k=>k===key);\n        //Remove previous keys\n        this.keyring = this.keyring.splice(i);\n      }, KeyTimeout);\n    };\n  }\n\n  async decrypt(type, ssrcId, header, encryptedFrame, skip)\n  {\n    let authTag, payload, extrabytes = 0, signature, signed;\n    const prevAuthTags = [];\n\n    // console.warn('BOO: BigWorker.Receiver: decrypt');\n    //convert if needed\n    if (!(encryptedFrame instanceof Uint8Array))\n      encryptedFrame = new Uint8Array (encryptedFrame);\n\n    //Replay attack protection\n    if (header.counter<this.maxReceivedCounter && this.maxReceivedCounter-header.counter>ReplayWindow)\n      //Error\n      throw new Error(\"Replay check failed, frame counter too old\");\n\n    //Check if frame contains signature\n    if (header.signature)\n    {\n      //Start from the end\n      let end = encryptedFrame.byteLength;\n\n      //Get lengths\n      const singatureLength = ECDSAVerifyKey.getSignatureLen();\n      const authTagLength   = AesCm128HmacSha256EncryptionKey.getAuthTagLen(type);\n\n      //Get signature\n      signature = encryptedFrame.subarray(end - singatureLength, end);\n      //Move backward\n      end -= singatureLength;\n\n      //Get number of tags\n      const num = encryptedFrame[end--];\n\n      //Read all tags\n      for (let i=0; i<num; ++i)\n      {\n        //Get previous tag\n        const prevTag = encryptedFrame.subarray(end - authTagLength, end);\n        //Move backward\n        end -= authTagLength;\n        //Add tag to previous tags in hex\n        prevAuthTags.push(Utils.toHex(prevTag))\n      }\n      //Get the extra bytes\n      extrabytes = encryptedFrame.byteLength - end;\n\n      //Move backward to start oth current frame auth tag\n      end -= authTagLength;\n\n      //Get singed part\n      signed = encryptedFrame.subarray(end, encryptedFrame.byteLength - singatureLength)\n    }\n\n    //For each key in key ring\n    for (let i=0;i<this.keyring.length;++i)\n    {\n      //Get key from ring\n      const key = this.keyring[i];\n      try {\n        //Try to decrypt payload\n        [payload, authTag] = await key.decrypt(type, header, encryptedFrame, extrabytes, skip);\n        //Done\n        break;\n      } catch(e) {\n\n      }\n    }\n\n    //If not found yet\n    if (!payload)\n    {\n      //Get last key\n      let key = this.keyring[this.keyring.length-1];\n\n      //Try ractchet last key\n      for (let i=this.numKeyRatchets; i<MaxRachetAttemtps; ++i)\n      {\n        //Rachet key\n        key = await key.ratchet();\n\n        //Append to the keyring\n        this.keyring.push(key);\n\n        try {\n          //Try to decrypt payload\n          [payload, authTag] = await key.decrypt(type, header, encryptedFrame, extrabytes, skip);\n          //Activate\n          this.schedulePreviousKeysTimeout(key);\n          //Done\n          break;\n        } catch(e) {\n\n        }\n      }\n    }\n\n    //Last check\n    if (!payload)\n      //Decryption failed\n      throw new Error(\"Decryption failed\");\n\n    //If we are sending part of the frame in clear\n    if (skip)\n      //Copy skiped payload\n      payload.set(encryptedFrame.subarray(0,skip),0);\n\n    //Check if have received anything from this ssrc before\n    if (!this.pending.has(ssrcId))\n      //Add it\n      this.pending.set(ssrcId,new Set());\n\n    //Get pending list\n    const pending = this.pending.get(ssrcId);\n\n    //Check if it constains signatures\n    if (header.signed)\n    {\n      //try to verify list\n      if (!await this.verifyKey.verify(signed,signature))\n        //Error\n        throw new Error(\"Could not verify signature\");\n      //For each signed tag\n      for (const tag in prevAuthTags)\n        //Delete from pending to be verified tags\n        pending.delete(tag);\n    } else {\n      //Push this tag to\n      pending.add(Utils.toHex(authTag));\n    }\n\n    //Set authenticated sender id and frame Id\n    payload.senderId = header.keyId;\n    payload.frameId  = header.counter;\n\n    //Store last received counter\n    this.maxReceivedCounter = Math.max(header.counter, this.maxReceivedCounter);\n\n    //Return decrypted payload\n    return payload;\n  }\n\n  async setVerifyKey(key)\n  {\n    //Create new singing key\n    this.verifyKey = EcdsaVerifyKey.create(key);\n  }\n\n  async setEncryptionKey(raw)\n  {\n    //Create new encryption key\n    const key = await AesCm128HmacSha256EncryptionKey.create(raw);\n    //Append to the keyring\n    this.keyring.push(key);\n    //Restart ratchet count number\n    this.numKeyRatchets = 0;\n    //Activate\n    this.schedulePreviousKeysTimeout(key);\n  }\n};\n\nclass Context\n{\n\n  constructor(senderId, config)\n  {\n    //Store config\n    this.config = Object.assign({}, config);\n    //Only one sender per context\n    this.sender = new Sender(senderId);\n\n    //The map of known remote senders\n    this.receivers = new Map();\n  }\n\n  isSkippingVp8PayloadHeader()\n  {\n    return !!this.config.skipVp8PayloadHeader;\n  }\n\n  async setSenderEncryptionKey(key)\n  {\n    //Set it\n    return this.sender.setEncryptionKey(key);\n  }\n\n  async ratchetSenderEncryptionKey()\n  {\n    //Set it\n    return this.sender.ratchetEncryptionKey();\n  }\n\n  async setSenderSigningKey(key)\n  {\n    //Set it\n    return this.sender.setSigningKey(key);\n  }\n\n  addReceiver(receiverkKeyId)\n  {\n    console.warn('BOO: addReceiver');\n    //Check we don't have a receiver already for that id\n    if(this.receivers.has(receiverkKeyId)) {\n      console.warn('BOO: ... error');\n      //Error\n      throw new Error(\"There was already a receiver for keyId \"+receiverkKeyId);\n    }\n\n    //Add new\n    this.receivers.set(receiverkKeyId, new Receiver(receiverkKeyId));\n    console.warn('BOO: ... done addReceiver');\n  }\n\n  async setReceiverEncryptionKey(receiverkKeyId, key)\n  {\n    console.warn('BOO: setReceiverEncryptionKey');\n    //Get receiver for the sender\n    const receiver = this.receivers.get(receiverkKeyId);\n\n    //IF not found\n    if (!receiver) {\n      console.warn('BOO: ... error');\n      //Error\n      throw new Error(\"No receiver found for keyId \"+receiverkKeyId);\n    }\n\n    //Rachet\n    const status = await receiver.setEncryptionKey(key);\n    console.warn(`BOO: ${status}`);\n\n    console.warn('BOO: done');\n    return status;\n  }\n\n  async setReceiverVerifyKey(receiverkKeyId,key)\n  {\n    console.warn('BOO: setReceiverVerifyKey');\n    //Get receiver for the sender\n    const receiver = this.receivers.get(receiverkKeyId);\n\n    //IF not found\n    if (!receiver) {\n      console.warn('BOO: error');\n      //Error\n      throw new Error(\"No receiver found for keyId \"+receiverkKeyId);\n    }\n\n    //Rachet\n    const status = await receiver.setVerifyKey(key);\n    console.warn(`BOO: status ${status}`);\n\n    console.warn('BOO: done');\n    return status;\n  }\n\n  deleteReceiver(receiverkKeyId)\n  {\n    //Delete receiver\n    return this.receivers.delete(receiverkKeyId);\n  }\n\n  async encrypt(type, ssrcId, frame, skip)\n  {\n    //Encrypt it\n    return this.sender.encrypt(type, ssrcId, frame, skip);\n  }\n\n  async decrypt(type, ssrcId, encryptedFrame, skip)\n  {\n    //convert if needed\n    if (!(encryptedFrame instanceof Uint8Array))\n      encryptedFrame = new Uint8Array (encryptedFrame);\n\n    //Parse encrypted payload\n    const header = Header.parse(encryptedFrame.subarray(skip));\n\n    //Get receiver for the sender\n    const receiver = this.receivers.get(header.keyId);\n\n    //IF not found\n    if (!receiver)\n      //Error\n      throw new Error(\"No receiver found for keyId \" + header.keyId);\n\n    //Decrypt it\n    return receiver.decrypt(type, ssrcId, header, encryptedFrame, skip);\n  }\n\n};\n\n\nconst VP8PayloadHeader = {\n\n  parse : function(buffer)\n  {\n    //Check size\n    if (buffer.byteLength<3)\n      //Invalid\n      return null;\n\n    //Create uint view\n    const view = new Uint8Array(buffer);\n\n    //Read comon 3 bytes\n    //   0 1 2 3 4 5 6 7\n    //  +-+-+-+-+-+-+-+-+\n    //  |Size0|H| VER |P|\n    //  +-+-+-+-+-+-+-+-+\n    //  |     Size1     |\n    //  +-+-+-+-+-+-+-+-+\n    //  |     Size2     |\n    //  +-+-+-+-+-+-+-+-+\n    const firstPartitionSize\t= view[0] >> 5;\n    const showFrame\t\t\t= view[0] >> 4 & 0x01;\n    const version\t\t\t= view[0] >> 1 & 0x07;\n    const isKeyFrame\t\t= (view[0] & 0x01) == 0;\n\n    //check if more\n    if (isKeyFrame)\n    {\n      //Check size\n      if (buffer.byteLength<10)\n        //Invalid\n        return null;\n      //Get size in le\n      const hor = view[7]<<8 | view[6];\n      const ver = view[9]<<8 | view[8];\n      //Get dimensions and scale\n      const width\t\t= hor & 0x3fff;\n      const horizontalScale   = hor >> 14;\n      const height\t\t= ver & 0x3fff;\n      const verticalScale\t= ver >> 14;\n      //Key frame\n      return view.subarray (0,10);\n    }\n\n    //No key frame\n    return view.subarray (0,3);\n  }\n};\n\nclass TaskQueue\n{\n  constructor()\n  {\n    this.tasks = [];\n    this.running = false;\n  }\n\n  enqueue(promise,callback,error)\n  {\n    //enqueue task\n    this.tasks.push({promise,callback,error});\n    //Try run\n    this.run();\n  }\n\n  async run()\n  {\n    //If already running\n    if (this.running)\n      //Nothing\n      return;\n    //Running\n    this.running = true;\n    //Run all pending tasks\n    while(this.tasks.length)\n    {\n      try {\n        //Wait for first promise to finish\n        const result = await this.tasks[0].promise;\n        //Run callback\n        this.tasks[0].callback(result);\n      } catch(e) {\n        //Run error callback\n        this.tasks[0].error(e);\n      }\n      //Remove task from queue\n      this.tasks.shift();\n    }\n    //Ended\n    this.running = false;\n  }\n}\nlet context;\n\nonmessage = async (event) => {\n  //Get data\n  const {transId,cmd,args} = event.data;\n\n  try {\n    let result = true;\n\n    console.warn(`BOO: ***** BigWorker cmd ${event.data.cmd}`);\n    //Depending on the cmd\n    switch(event.data.cmd)\n    {\n      case \"init\":\n      {\n        console.warn('BOO: init');\n        //Get info\n        const {senderId, config} = args;\n        //Crate context\n        context = new Context(senderId, config);\n        break;\n      }\n      case \"encrypt\":\n      {\n        console.warn('BOO: encrypt');\n        //The recrypt queue\n        const tasks = new TaskQueue();\n        //Get event data\n        // const{id, kind, readableStream, writableStream} = args;\n        const{id, kind, stream} = args;\n        //Create transform stream foo encrypting\n        const transformStream = new TransformStream({\n          transform: async (chunk, controller)=>{\n            //Nothing in clear\n            let skip = 0;\n            //Check if it is video and we are skipping vp8 payload header\n            if (kind==\"video\" && context.isSkippingVp8PayloadHeader())\n            {\n              //Get VP8 header\n              const vp8 = VP8PayloadHeader.parse(chunk.data);\n              //Skip it\n              skip = vp8.byteLength;\n            }\n            //Enqueue task\n            tasks.enqueue (\n              context.encrypt(kind, id, chunk.data, skip),\n              (encrypted) => {\n                //Set back encrypted payload\n                chunk.data = encrypted.buffer;\n                //write back\n                controller.enqueue(chunk);\n              },\n              (error)=>{\n                //TODO: handle errors\n                console.warn(`BOO: encrypting error ${error}`);\n              }\n            );\n          }\n        });\n        //Encrypt\n        // readableStream\n        try {\n          stream.readable\n            .pipeThrough(transformStream)\n          // .pipeTo(writableStream);\n            .pipeTo(stream.writable);\n        } catch (err) {\n          console.warn(`BOO: more encrypting errors ${err}`);\n        }\n        break;\n      }\n      case \"decrypt\":\n      {\n        console.warn('decrypt');\n        //The recrypt queue\n        const tasks = new TaskQueue();\n        //Last reveiced senderId\n        let senderId = -1;\n        //Get event data\n        // const{id, kind, readableStream, writableStream} = args;\n        const{id, kind, stream} = args;\n        //Create transform stream for encrypting\n        const transformStream = new TransformStream({\n          transform: async (chunk, controller)=>{\n            //Nothing in clear\n            let skip = 0;\n            //Check if it is video and we are skipping vp8 payload header\n            if (kind==\"video\" && context.isSkippingVp8PayloadHeader())\n            {\n              //Get VP8 header\n              const vp8 = VP8PayloadHeader.parse(chunk.data);\n              //Skip it\n              skip = vp8.byteLength;\n            }\n            //Enqueue task\n            tasks.enqueue (\n              context.decrypt(kind, id, chunk.data, skip),\n              (decrypted) => {\n                //Set back decrypted payload\n                chunk.data = decrypted.buffer;\n                //write back\n                controller.enqueue(chunk);\n                //If it is a sender\n                if (decrypted.senderId!=senderId)\n                {\n                  //Store it\n                  senderId = decrypted.senderId;\n                  //Launch event\n                  postMessage ({event: {\n                    name\t: \"authenticated\",\n                    data\t: {\n                      id\t : id,\n                      senderId : senderId\n                    }\n                  }});\n                }\n              },\n              (error)=>{\n                //TODO: handle errors\n                // console.warn(`BOO: decrypting error ${error}`);\n              }\n            );\n          }\n        });\n        //Decrypt\n        // readableStream\n        //   .pipeThrough(transformStream)\n        //   .pipeTo(writableStream);\n        try {\n          stream.readable\n            .pipeThrough(transformStream)\n            .pipeTo(stream.writable);\n        } catch (err) {\n          console.warn(`BOO: more decrypting errors ${err}`);\n        }\n        break;\n      }\n      default:\n      //Excute \"cmd\" method on context\n      result = await context[cmd](...args || []);\n    }\n    //Send result back\n    postMessage ({transId,result});\n  } catch (error) {\n    console.error(error);\n    //Send error back\n    postMessage({transId,error});\n  }\n};\n\n\n//# sourceURL=webpack:///./lib/sframe.worker.js?");

/***/ })

/******/ });